


<%
//////////////////////
// montgomeryTemplate
//////////////////////
// This function creates functions with the montgomery transformation
// applied
// the round hook allows to add diferent code in the iteration
//
//  All the montgomery functions modifies:
//  r8, r9, 10, r11, rax, rcx
//////////////////////
function montgomeryTemplate(fnName, round) {
    let r0, r1, r2;
    function setR(step) {
        if ((step % 3) == 0) {
            r0 = "r8";
            r1 = "r9";
            r2 = "r10";
        } else if ((step % 3) == 1) {
            r0 = "r9";
            r1 = "r10";
            r2 = "r8";
        } else {
            r0 = "r10";
            r1 = "r8";
            r2 = "r9";
        }
    }

    const base = bigInt.one.shiftLeft(64);
    const np64 = base.minus(q.modInv(base));
%>
<%=fnName%>:
        sub     rsp, <%= n64*8 %>  ; Reserve space for ms
        mov     rcx, rdx            ; rdx is needed for multiplications so keep it in cx
        mov     r11, 0x<%= np64.toString(16) %> ; np
        xor     r8,r8
        xor     r9,r9
        xor     r10,r10
<%
    // Main loop
    for (let i=0; i<n64*2; i++) {
        setR(i);
        round(i, r0, r1, r2);
%>

<%
        for (let j=i-1; j>=0; j--) { // All ms
            if (((i-j)<n64)&&(j<n64)) {
%>
        mov     rax, [rsp + <%= j*8 %>]
        mul     qword [q + <%= (i-j)*8 %>]
        add     <%= r0 %>, rax
        adc     <%= r1 %>, rdx
        adc     <%= r2 %>, 0x0
<%
            }
        } // ms
%>

<%
        if (i<n64) {
%>
        mov     rax, <%= r0 %>
        mul     r11
        mov     [rsp + <%= i*8 %>], rax
        mul     qword [q]
        add     <%= r0 %>, rax
        adc     <%= r1 %>, rdx
        adc     <%= r2 %>, 0x0
<%
        } else {
%>
        mov     [rdi + <%= (i-n64)*8 %> ], <%= r0 %>
        xor     <%= r0 %>,<%= r0 %>
<%
        }
%>

<%
    }   // Main Loop
%>
        test    <%= r1 %>, <%= r1 %>
        jnz     <%=fnName%>_mulM_sq
        ; Compare with q
<%
    for (let i=0; i<n64; i++) {
%>
        mov rax, [rdi + <%= (n64-i-1)*8 %>]
        cmp rax, [q + <%= (n64-i-1)*8 %>]
        jc <%=fnName%>_mulM_done        ; q is bigget so done.
        jnz <%=fnName%>_mulM_sq         ; q is lower
<%
    }
%>
        ; If equal substract q

<%=fnName%>_mulM_sq:
<%
    for (let i=0; i<n64; i++) {
%>
        mov rax, [q + <%= i*8 %>]
        <%= i==0 ? "sub" : "sbb" %> [rdi + <%= i*8 %>], rax
<%
    }
%>

<%=fnName%>_mulM_done:
        mov rdx, rcx            ; recover rdx to its original place.
        add rsp, <%= n64*8 %>   ; recover rsp
        ret

<%
}   // Template
%>

;;;;;;;;;;;;;;;;;;;;;;
; rawMontgomeryMul
;;;;;;;;;;;;;;;;;;;;;;
; Multiply two elements in montgomery form
; Params:
;   rsi <= Pointer to the long data of element 1
;   rdx <= Pointer to the long data of element 2
;   rdi <= Pointer to the long data of result
; Modified registers:
;    r8, r9, 10, r11, rax, rcx
;;;;;;;;;;;;;;;;;;;;;;
<%
montgomeryTemplate("rawMontgomeryMul2", function(i, r0, r1, r2) {
    // Same Digit
    for (let o1=Math.max(0, i-n64+1); (o1<=i)&&(o1<n64); o1++) {
    const o2= i-o1;
%>
        mov     rax, [rsi + <%= 8*o1 %>]
        mul     qword [rcx + <%= 8*o2 %>]
        add     <%= r0 %>, rax
        adc     <%= r1 %>, rdx
        adc     <%= r2 %>, 0x0
<%
    } // Same digit
})
%>

;;;;;;;;;;;;;;;;;;;;;;
; rawMontgomerySquare
;;;;;;;;;;;;;;;;;;;;;;
; Square an element
; Params:
;   rsi <= Pointer to the long data of element 1
;   rdi <= Pointer to the long data of result
; Modified registers:
;    r8, r9, 10, r11, rax, rcx
;;;;;;;;;;;;;;;;;;;;;;
<%
montgomeryTemplate("rawMontgomerySquare", function(i, r0, r1, r2) {
    // Same Digit
    for (let o1=Math.max(0, i-n64+1); (o1<((i+1)>>1) )&&(o1<n64); o1++) {
    const o2= i-o1;
%>
        mov     rax, [rsi + <%= 8*o1 %>]
        mul     qword [rsi + <%= 8*o2 %>]
        add     <%= r0 %>, rax
        adc     <%= r1 %>, rdx
        adc     <%= r2 %>, 0x0
        add     <%= r0 %>, rax
        adc     <%= r1 %>, rdx
        adc     <%= r2 %>, 0x0
<%
    } // Same digit
%>

<%  if (i%2 == 0) { %>
        mov     rax, [rsi + <%= 8*(i/2) %>]
        mul     rax
        add     <%= r0 %>, rax
        adc     <%= r1 %>, rdx
        adc     <%= r2 %>, 0x0
<%  } %>

<%
})
%>


;;;;;;;;;;;;;;;;;;;;;;
; rawMontgomeryMul1
;;;;;;;;;;;;;;;;;;;;;;
; Multiply two elements in montgomery form
; Params:
;   rsi <= Pointer to the long data of element 1
;   rdx <= second operand
;   rdi <= Pointer to the long data of result
; Modified registers:
;    r8, r9, 10, r11, rax, rcx
;;;;;;;;;;;;;;;;;;;;;;
<%
montgomeryTemplate("rawMontgomeryMul1", function(i, r0, r1, r2) {
    // Same Digit
    if (i<n64) {
%>
        mov     rax, [rsi + <%= 8*i %>]
        mul     rcx
        add     <%= r0 %>, rax
        adc     <%= r1 %>, rdx
        adc     <%= r2 %>, 0x0
<%
    } // Same digit
})
%>


;;;;;;;;;;;;;;;;;;;;;;
; rawFromMontgomery
;;;;;;;;;;;;;;;;;;;;;;
; Multiply two elements in montgomery form
; Params:
;   rsi <= Pointer to the long data of element 1
;   rdi <= Pointer to the long data of result
; Modified registers:
;    r8, r9, 10, r11, rax, rcx
;;;;;;;;;;;;;;;;;;;;;;
<%
montgomeryTemplate("rawFromMontgomery", function(i, r0, r1, r2) {
    // Same Digit
    if (i<n64) {
%>
        add     <%= r0 %>, [rdi + <%= 8*i %>]
        adc     <%= r1 %>, 0x0
        adc     <%= r2 %>, 0x0
<%
    } // Same digit
})
%>

;;;;;;;;;;;;;;;;;;;;;;
; toMontgomery
;;;;;;;;;;;;;;;;;;;;;;
; Convert a number to Montgomery
;   rdi <= Pointer element to convert
; Modified registers:
;    r8, r9, 10, r11, rax, rcx
;;;;;;;;;;;;;;;;;;;;
<%=name%>_toMontgomery:
    mov     rax, [rdi]
    bt      rax, 62                     ; check if montgomery
    jc      toMontgomery_doNothing
    bt      rax, 63
    jc      toMontgomeryLong

toMontgomeryShort:
    add     rdi, 8
    push    rsi
    push    rdx
    lea     rsi, [R2]
    movsx   rdx, eax
    cmp     rdx, 0
    js      negMontgomeryShort
posMontgomeryShort:
    call    rawMontgomeryMul1
    pop     rdx
    pop     rsi
    sub     rdi, 8
    <%=     global.setTypeDest("0x40"); %>
    ret

negMontgomeryShort:
    neg     rdx              ; Do the multiplication positive and then negate the result.
    call    rawMontgomeryMul1
    mov     rsi, rdi
    call    rawNegL
    pop     rdx
    pop     rsi
    sub     rdi, 8
    <%=     global.setTypeDest("0x40"); %>
    ret


toMontgomeryLong:
    mov     [rdi], rax
    add     rdi, 8
    push    rsi
    mov     rdx, rdi
    lea     rsi, [R2]
    call    rawMontgomeryMul
    pop     rsi
    sub     rdi, 8
    <%=     global.setTypeDest("0xC0"); %>


toMontgomery_doNothing:
    ret

;;;;;;;;;;;;;;;;;;;;;;
; toNormal
;;;;;;;;;;;;;;;;;;;;;;
; Convert a number from Montgomery
;   rdi <= Pointer element to convert
; Modified registers:
;    r8, r9, 10, r11, rax, rcx
;;;;;;;;;;;;;;;;;;;;
<%=name%>_toNormal:
    mov     rax, [rdi]
    bt      rax, 62                     ; check if montgomery
    jnc     toNormal_doNothing
    bt      rax, 63                     ; if short, it means it's converted
    jnc     toNormal_doNothing

toNormalLong:
    add     rdi, 8
    call    rawFromMontgomery
    sub     rdi, 8
    <%=     global.setTypeDest("0x80"); %>

toNormal_doNothing:
    ret

;;;;;;;;;;;;;;;;;;;;;;
; toLongNormal
;;;;;;;;;;;;;;;;;;;;;;
; Convert a number to long normal
;   rdi <= Pointer element to convert
; Modified registers:
;    r8, r9, 10, r11, rax, rcx
;;;;;;;;;;;;;;;;;;;;
<%=name%>_toLongNormal:
    mov     rax, [rdi]
    bt      rax, 62                     ; check if montgomery
    jc      toLongNormal_fromMontgomery
    bt      rax, 63                     ; check if long
    jnc     toLongNormal_fromShort
    ret                                 ; It is already long

toLongNormal_fromMontgomery:
    add     rdi, 8
    call    rawFromMontgomery
    sub     rdi, 8
    <%=     global.setTypeDest("0x80"); %>
    ret

toLongNormal_fromShort:
    mov     r8, rsi                     ; save rsi
    movsx   rsi, eax
    call    rawCopyS2L
    mov     rsi, r8                     ; recover rsi
    <%=     global.setTypeDest("0x80"); %>
    ret

<%
// Important Documentation:
// https://www.microsoft.com/en-us/research/wp-content/uploads/1998/06/97Acar.pdf
// https://hackmd.io/@zkteam/modular_multiplication#Benchmarks
// 
/*
    function buildMontgomeryMul(fn) {

        const n64 = Math.floor((q.bitLength() - 1) / 64)+1;
        let code = [];
        const canOptimizeConsensys = q.shiftRight((n64-1)*64).leq( bigInt.one.shiftLeft(64).minus(1).shiftRight(1).minus(1) );
        const base = bigInt.one.shiftLeft(64);
        const np64 = base.minus(q.modInv(base));
    
        const t=4;
        let wrAvailable;
        let wrAssignments = [];
        let pushedRegs = [];
    
        let nUsedRegs;
        let regRefs = [];
        let neededRegs;
    
        // const availableRegs = ["tmp0", "tmp1", "np64", "r0", "t0"];
        // const pushableRegs = ["t1", "t2", "t3", "t4", "wc"];
        // const allRegs = ["rdi", "rdx", "rcx", "rsi", "tmp0", "tmp1", "np64", "r0", "t0","t1", "t2", "t3", "t4", "wc"];
    
        const availableRegs = ["rax", "r8", "r9", "r10", "r11"];
        const pushableRegs = ["rbp", "r12", "r13", "r14", "r15", "rbx"];
        const allRegs = ["rax", "rbx", "rcx", "rdx", "rdi", "rsi", "rsp", "rbp", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"];
    
        function startFn() {
    
            neededRegs = t + n64 + 2 - (canOptimizeConsensys ? 1 : 0);
            if (neededRegs > availableRegs.length + pushableRegs.length) {
                nUsedRegs = availableRegs.length + pushableRegs.length -1;
                wrAvailable = [pushableRegs[pushableRegs.length-1]];
            } else {
                nUsedRegs = neededRegs;
                wrAvailable = null;
            }
            for (let i=0; i<neededRegs; i++) {
                if (i < availableRegs.length) {
                    regRefs[i] = availableRegs[i];
                } else if (i<nUsedRegs) {
                    regRefs[i] = pushableRegs[i-availableRegs.length];
                } else {
                    regRefs[i] = `[rsp + ${(i-nUsedRegs)*8  }]`;
                }
                if (   (i>=availableRegs.length)
                    &&(i<availableRegs.length+pushableRegs.length))
                {
                    code.push(`    push ${pushableRegs[i-availableRegs.length]}`);
                    pushedRegs.push(pushableRegs[i-availableRegs.length])
                }
            }
            if (neededRegs>nUsedRegs) {
                code.push(`    sub rsp, ${(neededRegs-nUsedRegs)*8}`);
            }
        }
    
        function finishFn() {
            if (neededRegs>nUsedRegs) {
                code.push(`    add rsp, ${(neededRegs-nUsedRegs)*8}`);
            }
            for (let i=pushedRegs.length-1; i>=0; i--) {
                code.push(`    pop ${pushedRegs[i]}`);
            }
        }
    
        function findWrAssignment(n) {
            for (let i=0; i<wrAssignments.length; i++) {
                if (wrAssignments[i].ref == n) return i;
            }
            return -1;
        }
    
        function flushWr(removeAssignments) {
            for (let i=wrAssignments.length-1; i>=0; i--) {
                if (wrAssignments[i].modified) {
                    code.push(`    mov ${regRefs[wrAssignments[i].ref]}, ${wrAssignments[i].reg}`);
                    wrAssignments[i].modified = false;
                }
                if (removeAssignments) {
                    wrAvailable.push(wrAssignments[i].reg);
                    wrAssignments.pop();
                }
            }
        }
    
        function loadWr(n, loadValue) {
            const idx = findWrAssignment(n);
            if (idx>=0) {
                wrAssignments.push(wrAssignments.splice(idx, 1)[0]); // Move it to the end
            } else {
                if (wrAvailable.length == 0) {
                    if (wrAssignments[0].modified) {
                        code.push(`    mov ${regRefs[wrAssignments[0].ref]}, ${wrAssignments[0].reg}`);
                    }
                    wrAvailable.push(wrAssignments[0].reg);
                    wrAssignments.shift();
                }
                const a = {
                    reg: wrAvailable.shift(),
                    ref: n,
                };
                wrAssignments.push(a);
                if (loadValue) {
                    code.push(`    mov ${a.reg}, ${regRefs[n]}`);
                }
            }
    
            return wrAssignments[wrAssignments.length-1];
        }
    
    
        function op3(inst, ...args) {
            let ref = [];
            let preload = 0;
            for (let i=0; i < 3; i++) {
                if (typeof args[i] !== "undefined") {
                    if (typeof args[i] === "string") {
                        ref[i] = args[i];
                    } else {
                        const idx = findWrAssignment(i);
                        if (idx >= 0) {
                            ref[i] = wrAssignments[idx] .reg;
                        } else {
                            ref[i] = regRefs[args[i]];
                        }
                    }
                    if (i==1) {
                        const isReg = (allRegs.indexOf(ref[i]) >=0);
                        if (!isReg) preload = 2;
                    }
                } else {
                    ref[i] = false;
                }
            }
    
            if (preload == 0) {
                code.push(buildInst(inst, ref[0], ref[1], ref[2] ));
            } else if (preload == 2) {
                const wr = loadWr(args[1], false);
                code.push(buildInst(inst, ref[0], wr.reg, ref[2] ));
                wr.modified=true;
            } else if (preload == 2) {
                assert(false);
            }
    
            function buildInst(inst, r1, r2, r3) {
                let sdbg = "(none)";
                if (wrAssignments.length > 0) sdbg = regRefs[wrAssignments[0].ref];
                // let SS = sdbg + " " + inst;
                let SS = "    " + inst;
    
                if (r1) SS += " " + r1;
                if (r2) SS += "," + r2;
                if (r3) SS += "," + r3;
                return SS;
            }
        }
    
        function op(inst, ...args) {
    
            if (!["adcx", "adox", "sub", "sbb", "cmp","mov", "mulx"].indexOf(inst) < 0) {
                console.log(inst);
                assert(false );
            }
    
            code.push("");
    
            if (args[2]) return op3(inst, ...args);
    
            const mustbereg = [
                ["adcx", "adox"],
                [],
                []
            ];
    
            let ref = [];
            let preload = 0;
            let dUsed = false;
            for (let i=0; i < 2; i++) {
                if (typeof args[i] !== "undefined") {
                    if (typeof args[i] === "string") {
                        ref[i] = args[i];
                    } else {
                        const idx = findWrAssignment(i);
                        if (idx >= 0) {
                            ref[i] = wrAssignments[idx] .reg;
                        } else {
                            ref[i] = regRefs[args[i]];
                        }
                    }
                    const isReg = (allRegs.indexOf(ref[i]) >=0);
                    if (!isReg) {
                        if (  dUsed  || mustbereg[i].indexOf(inst)>=0) {
                            if ((i==1)&&(typeof args[i] === "string")) {
                                preload = 1;
                            } else {
                                preload = (1 << i);
                            }
                        } else {
                            dUsed = true;
                        }
                    }
                } else {
                    ref[i] = false;
                }
            }
    
            if (preload == 0) {
                code.push(buildInst(inst, ref[0], ref[1], ref[2] ));
            } else if (preload == 1) {
                const wr = loadWr(args[0], ["adcx", "adox", "sub", "sbb", "cmp"].indexOf(inst) >=0 );
                code.push(buildInst(inst, wr.reg, ref[1], ref[2] ));
                if (["adcx", "adox", "sbb"].indexOf(inst) >= 0) {
                    wr.modified=true;
                }
            } else if (preload == 2) {
                const wr = loadWr(args[1], true);
                code.push(buildInst(inst, ref[0], wr.reg, ref[2] ));
            } else {
                assert(false);
            }
    
            function buildInst(inst, r1, r2) {
                let sdbg = "(none)";
                if (wrAssignments.length > 0) sdbg = regRefs[wrAssignments[0].ref];
                // let SS = sdbg + " " + inst;
                let SS = "    " + inst;
                if (r1) SS += " " + r1;
                if (r2) SS += "," + r2;
                return SS;
            }
        }
    
        code.push(fn+":");
        startFn();
        op("mov","rcx","rdx");   // rdx is needed for multiplications so keep it in cx
        
        op("mov", 2, `0x${np64.toString(16)}`);
        op("xor", 3, 3);    
    
        code.push("");
        for (let i=0; i<n64; i++) {     
            code.push("; FirstLoop");
            op("mov","rdx", `[rsi + ${i*8}]`);
            if (i==0) {                                   
                op("mulx", 0, t, "[rcx]"); 
                for (let j=1; j<n64; j++) {               
                    op("mulx", j%2, t+j, `[rcx +${j*8}]`);
                    op("adcx", t+j, (j-1)%2);
                }
                if (!canOptimizeConsensys) {
                    op("mov", t+n64, 3);
                    op("adcx", t+n64 , (n64-1)%2);
                    op("mov", t+n64+1, 3);
                    op("adcx", t+n64+1, 3);
                } else {
                    op("mov", t+n64, 3);
                    op("adcx", t+n64 , (n64-1)%2);
                }                                   
            } else {     
                if (!canOptimizeConsensys) {
                    op("mov", t+n64+1, 3);
                } else {
                    op("mov", t+n64, 3);
                }                                                                                  
                for (let j=0; j<n64; j++) {               
                    op("mulx", 1, 0, `[rcx +${j*8}]`);
                    op("adcx", t+j, 0);
                    op("adox", t+j+1, 1);
                }
                if (!canOptimizeConsensys) {
                    op("adcx", t+n64, 3);
                    op("adcx", t+n64+1, 3);
                    op("adox", t+n64+1, 3);
                } else {
                    op("adcx", t+n64, 3);
                }                                                 
            }                                             
    
            code.push("; SecondLoop");              
            op("mov", "rdx", 2);
            op("mulx", 0, "rdx", t);
            op("mulx", 1, 0, "[q]");
            op("adcx", 0, t);
            for (let j=1; j<n64; j++) {                 
                op("mulx", (j+1)%2, t+j-1, `[q +${j*8}]`);
                op("adcx", t+j-1, j%2);
                op("adox", t+j-1, t+j);
            }
            op("mov", t+n64-1, 3);
            op("adcx", t+n64-1, n64%2);
            op("adox", t+n64-1, t+n64);
            if (!canOptimizeConsensys) {                 
                op("mov", t+n64, 3);
                op("adcx", t+n64, 3);
                op("adox", t+n64, t+n64+1);
            }
    
            code.push("");                                                           
        }                                                 
    
        code.push(";comparison");
        flushWr(false);
        if (!canOptimizeConsensys) {                 
            op("test", t+n64, t+n64);
            op("jnz", fn+"_sq");
        }
        for (let i=n64-1; i>=0; i--) {
            op("cmp", t+i, `[q + ${i*8}]`);
            op("jc", fn+"_done");
            op("jnz", fn+"_sq");
        }
    
        code.push(fn+ "_sq:");
        flushWr(true);
        for (let i=0; i<n64; i++) {
            op(i==0 ? "sub" : "sbb", t+i, `[q +${i*8}]`);
        }
        flushWr(true);
    
        code.push(fn+ "_done:");
        flushWr(true);
        wrAssignments = [];
        for (let i=0; i<n64; i++) {
            op("mov" ,  `[rdi + ${i*8}]`, t+i);
        }
    
        finishFn();
        op("ret");
    
        console.log(code.length);
        return code.join("\n");
    } */
%>  

<%= // buildMontgomeryMul("rawMontgomeryMul") %>